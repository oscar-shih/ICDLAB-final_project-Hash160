//////////////////////////////////////////////////////////////////////
// (C) Copyright 1993-2003 Faraday Technology Corp. All Rights Reserved.
// 
// FTC Verilog Simulation Library
//   Cell Library            : fsa0m_a
//   Library Release Version : 2008Q3V1.2
//   Date                    : Thu Aug 21 15:00:09 CST 2008 
//////////////////////////////////////////////////////////////////////
//
//   Note : This library uses delayed signals to support negative
//          timing checks.
//          Please add command-line options
//             "+neg_tchk" and "+nowarnNTCDSN" when runnning simulation with Verilog-XL
//             "+neg_tchk" when runnning simulation with NC-verilog
//          to support negative timing checks.
//
//////////////////////////////////////////////////////////////////////

`timescale 10ps / 1ps

//-- FTC standard cell revision 1.1 --//
`resetall
`timescale 10ps/1ps
`celldefine
module XMC(O, I, PU, PD, SMT);
   output O;
   input I, PU, PD, SMT;
   supply1 vcc;

//Function Block
`protect
   // Avoide MIPD
   buf b1 (SMT_,SMT);
`ifdef atpgmodel
   buf g1 (O,I);
`else
   nmos   g1(io1, I, vcc);
   not    g2(pub, PU);
   not    g3(pdb, PD);
   and    g4(pupd, PU, PD);
   and    g5(pu_pd_, pub, pdb);
   or     g6(pcon, pupd, pu_pd_);
   or     g7(pull_down1, pdb, PU);
   rpmos  g8(io1, pull_down1, pcon);
   buf    g9(O,io1);
   //-- bus holder for "keep" function --//
   buf    g10 (z,io1);
   buf    g11 (H,z);
   rnmos  g12 (io1, H, pupd);
`endif

//Specify Block
   specify

      //  Module Path Delay
      if (SMT == 0) (I *> O) = (42.88:57.36:85.27, 32.39:42.49:60.67);
      if (SMT == 1) (I *> O) = (46.24:60.46:87.84, 40.94:49.75:67.66);
   endspecify
`endprotect
endmodule
`endcelldefine


//-- FTC standard cell revision 1.1 --//
`resetall
`timescale 10ps/1ps
`celldefine
module XMD(O, I, PU, PD, SMT);
   output O;
   input I, PU, PD, SMT;
   supply1 vcc;

//Function Block
`protect
   // Avoide MIPD
   buf b1 (SMT_,SMT);
`ifdef atpgmodel
   buf g1 (O,I);
`else
   nmos   g1(io1, I, vcc);
   not    g2(pub, PU);
   not    g3(pdb, PD);
   and    g4(pupd, PU, PD);
   and    g5(pu_pd_, pub, pdb);
   or     g6(pcon, pupd, pu_pd_);
   or     g7(pull_down1, pdb, PU);
   rpmos  g8(io1, pull_down1, pcon);
   buf    g9(O,io1);
   //-- bus holder for "keep" function --//
   buf    g10 (z,io1);
   buf    g11 (H,z);
   rnmos  g12 (io1, H, pupd);
`endif

//Specify Block
   specify

      //  Module Path Delay
      if (SMT == 0) (I *> O) = (41.93:56.09:83.28, 31.87:41.89:59.84);
      if (SMT == 1) (I *> O) = (45.33:59.21:85.88, 40.45:49.14:66.75);
   endspecify
`endprotect
endmodule
`endcelldefine


//-- FTC standard cell revision 1.1 --//
`resetall
`timescale 10ps/1ps
`celldefine
module YA2GSC(O, I, E, E2, E4, E8, SR);
   output O;
   input I, E, E2, E4, E8, SR;

//Function Block
`protect
   // Avoide MIPD
   buf b1 (E2_,E2);
   buf b2 (E4_,E4);
   buf b3 (E8_,E8);
   buf b4 (SR_,SR);

   bufif1 g1(O, I, E);

//Specify Block
   specify

      //  Module Path Delay
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (E *> O) = (110.02:151.80:239.61, 109.68:143.27:213.98, 87.80:114.55:172.94, 110.02:151.80:239.61, 63.45:79.76:115.39, 109.68:143.27:213.98);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (E *> O) = (121.61:166.46:260.48, 118.21:155.16:232.39, 87.92:114.87:173.59, 121.61:166.46:260.48, 63.46:80.16:116.06, 118.21:155.16:232.39);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (E *> O) = (90.46:125.10:199.13, 75.86:102.90:160.91, 95.90:124.26:185.71, 90.46:125.10:199.13, 81.40:100.84:143.25, 75.86:102.90:160.91);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (E *> O) = (112.31:152.66:238.10, 86.38:117.79:184.07, 96.00:124.44:185.94, 112.31:152.66:238.10, 80.91:101.35:143.44, 86.38:117.79:184.07);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (E *> O) = (90.62:125.19:199.07, 78.64:105.79:164.05, 94.34:122.33:183.24, 90.62:125.19:199.07, 74.22:92.63:131.28, 78.64:105.79:164.05);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (E *> O) = (108.89:148.42:232.21, 89.45:120.93:187.41, 94.45:122.55:183.62, 108.89:148.42:232.21, 74.27:92.47:131.45, 89.45:120.93:187.41);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (E *> O) = (91.80:126.82:201.69, 73.45:100.18:157.52, 98.17:127.02:189.41, 91.80:126.82:201.69, 84.53:106.42:149.84, 73.45:100.18:157.52);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (E *> O) = (118.95:160.97:249.16, 85.79:117.51:184.25, 98.26:127.18:189.59, 118.95:160.97:249.16, 85.01:106.10:150.11, 85.79:117.51:184.25);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (E *> O) = (94.10:129.98:206.29, 85.80:114.39:175.56, 90.66:117.88:177.15, 94.10:129.98:206.29, 70.35:87.83:125.10, 85.80:114.39:175.56);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (E *> O) = (109.83:149.99:234.97, 96.27:128.94:198.07, 90.77:118.11:177.58, 109.83:149.99:234.97, 70.38:88.22:125.55, 96.27:128.94:198.07);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (E *> O) = (91.16:126.01:200.52, 74.66:101.59:159.38, 96.56:125.09:186.76, 91.16:126.01:200.52, 83.45:103.72:147.16, 74.66:101.59:159.38);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (E *> O) = (116.20:157.54:244.59, 86.58:118.37:185.35, 96.65:125.25:186.95, 116.20:157.54:244.59, 83.46:104.16:147.52, 86.58:118.37:185.35);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (E *> O) = (90.12:124.52:198.12, 75.88:102.73:160.38, 95.21:123.41:184.64, 90.12:124.52:198.12, 77.56:96.91:137.03, 75.88:102.73:160.38);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (E *> O) = (111.77:151.91:236.76, 87.96:119.62:186.39, 95.31:123.62:184.93, 111.77:151.91:236.76, 77.54:96.95:137.37, 87.96:119.62:186.39);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (E *> O) = (93.18:128.61:204.26, 73.45:100.39:158.15, 98.67:127.63:190.18, 93.18:128.61:204.26, 86.70:108.69:152.99, 73.45:100.39:158.15);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (E *> O) = (122.96:166.13:256.24, 87.11:119.50:187.49, 98.75:127.77:190.37, 122.96:166.13:256.24, 86.78:108.25:153.23, 87.11:119.50:187.49);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (I *> O) = (118.46:162.11:253.79, 127.25:166.86:249.98);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (I *> O) = (129.87:176.56:274.59, 135.82:178.90:269.57);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (I *> O) = (99.06:135.47:213.60, 93.47:126.55:197.71);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (I *> O) = (120.71:162.89:252.47, 103.75:141.25:220.74);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (I *> O) = (99.24:135.57:213.51, 96.07:129.32:200.70);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (I *> O) = (117.29:158.61:246.48, 106.91:144.53:224.24);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (I *> O) = (100.29:137.09:216.08, 91.24:124.05:194.66);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (I *> O) = (127.36:171.22:263.58, 103.30:141.17:221.26);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (I *> O) = (102.64:140.29:220.68, 103.27:137.89:212.28);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (I *> O) = (118.24:160.19:249.24, 113.79:152.52:235.09);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (I *> O) = (99.68:136.31:214.92, 92.41:125.43:196.48);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (I *> O) = (124.62:167.78:259.00, 104.08:142.02:222.31);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (I *> O) = (98.66:134.81:212.48, 93.39:126.36:197.22);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (I *> O) = (120.16:162.11:251.06, 105.48:143.33:223.42);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (I *> O) = (101.62:138.81:218.61, 91.36:124.40:195.49);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (I *> O) = (131.39:176.41:270.72, 104.68:143.27:224.70);
   endspecify
`endprotect
endmodule
`endcelldefine


//-- FTC standard cell revision 1.1 --//
`resetall
`timescale 10ps/1ps
`celldefine
module YA2GSD(O, I, E, E2, E4, E8, SR);
   output O;
   input I, E, E2, E4, E8, SR;

//Function Block
`protect
   // Avoide MIPD
   buf b1 (E2_,E2);
   buf b2 (E4_,E4);
   buf b3 (E8_,E8);
   buf b4 (SR_,SR);

   bufif1 g1(O, I, E);

//Specify Block
   specify

      //  Module Path Delay
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (E *> O) = (106.96:147.48:232.34, 107.44:139.98:208.82, 83.30:108.26:163.06, 106.96:147.48:232.34, 62.52:78.39:112.66, 107.44:139.98:208.82);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (E *> O) = (118.16:161.68:252.72, 115.51:151.19:226.12, 83.48:108.65:163.73, 118.16:161.68:252.72, 62.37:78.47:113.43, 115.51:151.19:226.12);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (E *> O) = (86.77:119.83:190.49, 73.69:99.86:155.99, 91.61:118.23:176.14, 86.77:119.83:190.49, 79.33:99.14:139.76, 73.69:99.86:155.99);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (E *> O) = (107.80:146.37:228.03, 83.81:114.21:178.30, 91.71:118.45:176.34, 107.80:146.37:228.03, 79.40:99.18:140.10, 83.81:114.21:178.30);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (E *> O) = (87.07:120.16:190.81, 75.54:101.40:156.95, 89.35:115.46:172.52, 87.07:120.16:190.81, 72.84:90.73:128.20, 75.54:101.40:156.95);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (E *> O) = (104.74:142.59:222.82, 85.63:115.54:178.74, 89.48:115.74:172.87, 104.74:142.59:222.82, 72.82:90.63:128.44, 85.63:115.54:178.74);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (E *> O) = (87.95:121.33:192.70, 70.79:96.41:151.40, 93.58:120.64:179.33, 87.95:121.33:192.70, 83.31:104.09:146.26, 70.79:96.41:151.40);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (E *> O) = (113.96:154.04:238.20, 82.53:112.91:176.84, 93.68:120.82:179.51, 113.96:154.04:238.20, 83.30:103.80:146.45, 82.53:112.91:176.84);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (E *> O) = (90.50:124.85:197.90, 82.60:109.88:168.11, 85.75:111.09:166.60, 90.50:124.85:197.90, 68.98:85.88:122.15, 82.60:109.88:168.11);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (E *> O) = (105.60:144.06:225.41, 92.27:123.36:188.99, 85.89:111.40:166.99, 105.60:144.06:225.41, 68.99:86.27:122.52, 92.27:123.36:188.99);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (E *> O) = (87.26:120.44:191.39, 72.01:97.82:153.27, 92.05:118.82:176.89, 87.26:120.44:191.39, 81.49:101.86:143.42, 72.01:97.82:153.27);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (E *> O) = (111.16:150.52:233.50, 83.31:113.74:177.87, 92.15:119.00:177.05, 111.16:150.52:233.50, 81.73:101.79:143.73, 83.31:113.74:177.87);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (E *> O) = (86.33:119.12:189.26, 72.44:97.83:152.47, 90.07:116.37:173.67, 86.33:119.12:189.26, 75.92:94.40:133.30, 72.44:97.83:152.47);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (E *> O) = (107.02:145.29:226.22, 83.58:113.42:176.41, 90.19:116.60:173.92, 107.02:145.29:226.22, 75.94:94.65:133.90, 83.58:113.42:176.41);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (E *> O) = (89.12:122.83:194.83, 70.45:96.13:151.22, 93.90:121.09:179.90, 89.12:122.83:194.83, 84.94:106.24:149.25, 70.45:96.13:151.22);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (E *> O) = (117.50:158.54:244.35, 83.27:114.07:178.76, 94.00:121.24:180.02, 117.50:158.54:244.35, 84.94:105.87:149.36, 83.27:114.07:178.76);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (I *> O) = (116.81:159.64:249.98, 125.02:163.64:244.33);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (I *> O) = (127.88:173.82:270.26, 132.92:174.95:263.15);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (I *> O) = (96.64:132.09:208.19, 91.30:123.49:192.85);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (I *> O) = (117.54:158.54:245.68, 101.13:137.58:214.93);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (I *> O) = (96.95:132.40:208.47, 92.95:124.90:193.64);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (I *> O) = (114.47:154.73:240.39, 103.02:139.04:215.51);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (I *> O) = (97.72:133.51:210.35, 88.60:120.30:188.63);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (I *> O) = (123.71:166.24:255.92, 100.01:136.52:213.84);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (I *> O) = (100.32:137.06:215.56, 100.04:133.44:204.20);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (I *> O) = (115.34:156.21:242.99, 109.71:146.95:225.92);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (I *> O) = (97.05:132.64:209.05, 89.79:121.68:190.47);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (I *> O) = (120.91:162.71:251.20, 100.76:137.33:214.82);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (I *> O) = (96.12:131.30:206.86, 89.95:121.45:189.34);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (I *> O) = (116.75:157.45:243.83, 101.04:137.04:213.36);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (I *> O) = (98.85:134.96:212.44, 88.40:120.17:188.67);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (I *> O) = (127.26:170.78:262.13, 100.82:137.79:215.96);
   endspecify
`endprotect
endmodule
`endcelldefine


//-- FTC standard cell revision 1.1 --//
`resetall
`timescale 10ps/1ps
`celldefine
module ZMA2GSC(O, I, IO, E, E2, E4, E8, SR, PU, PD, SMT);
   output O;
   input I, E, E2, E4, E8, SR, PU, PD, SMT;
   inout IO;

//Function Block
`protect
   // Avoide MIPD
   buf b1 (E2_,E2);
   buf b2 (E4_,E4);
   buf b3 (E8_,E8);
   buf b4 (SR_,SR);
   buf b5 (SMT_,SMT);

   pullup_down_keep_IO g1 (IO, I, E, PU, PD);
   buf    g2 (O, IO);

//Specify Block
   specify

      //  Module Path Delay
      if (SMT == 0) (IO *> O) = (43.16:57.73:85.85, 32.56:42.71:60.99);
      if (SMT == 1) (IO *> O) = (46.52:60.83:88.43, 41.11:49.98:68.01);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (E *> IO) = (110.56:152.64:240.83, 110.81:144.36:216.04, 89.96:117.45:173.60, 110.56:152.64:240.83, 65.66:82.69:119.61, 110.81:144.36:216.04);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (E *> IO) = (122.12:167.14:261.63, 119.40:156.49:234.31, 90.18:117.79:177.06, 122.12:167.14:261.63, 65.66:83.08:120.18, 119.40:156.49:234.31);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (E *> IO) = (90.49:125.14:199.21, 76.50:103.76:162.24, 98.32:127.43:186.89, 90.49:125.14:199.21, 83.60:104.38:147.41, 76.50:103.76:162.24);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (E *> IO) = (112.42:152.81:238.32, 87.17:118.86:185.72, 98.46:127.63:189.85, 112.42:152.81:238.32, 83.26:104.18:148.01, 87.17:118.86:185.72);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (E *> IO) = (90.71:125.32:199.27, 79.03:106.26:164.71, 96.52:125.23:183.76, 90.71:125.32:199.27, 76.49:95.60:135.51, 79.03:106.26:164.71);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (E *> IO) = (109.04:148.62:232.50, 89.88:121.47:188.17, 96.69:125.49:187.13, 109.04:148.62:232.50, 76.53:95.75:135.96, 89.88:121.47:188.17);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (E *> IO) = (91.80:126.83:201.71, 73.92:100.81:158.48, 100.55:130.13:190.54, 91.80:126.83:201.71, 87.15:109.27:154.17, 73.92:100.81:158.48);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (E *> IO) = (119.06:161.10:249.36, 86.42:118.36:185.56, 100.67:130.30:193.40, 119.06:161.10:249.36, 87.27:108.91:154.55, 86.42:118.36:185.56);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (E *> IO) = (94.32:130.27:206.74, 86.28:115.03:176.50, 92.83:120.77:177.68, 94.32:130.27:206.74, 72.57:90.83:129.45, 86.28:115.03:176.50);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (E *> IO) = (110.08:150.32:235.48, 96.83:129.67:199.07, 92.99:121.03:181.06, 110.08:150.32:235.48, 72.61:91.11:129.88, 96.83:129.67:199.07);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (E *> IO) = (91.18:126.03:200.56, 75.19:102.31:160.49, 98.95:128.22:188.00, 91.18:126.03:200.56, 85.50:107.15:151.47, 75.19:102.31:160.49);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (E *> IO) = (116.32:157.67:244.80, 87.27:119.31:186.79, 99.07:128.38:190.82, 116.32:157.67:244.80, 85.72:106.88:151.66, 87.27:119.31:186.79);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (E *> IO) = (90.16:124.58:198.21, 76.20:103.12:160.94, 97.40:126.32:185.26, 90.16:124.58:198.21, 79.82:99.53:141.32, 76.20:103.12:160.94);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (E *> IO) = (111.88:152.06:236.99, 88.34:120.10:187.06, 97.55:126.53:188.43, 111.88:152.06:236.99, 79.79:100.03:141.58, 88.34:120.10:187.06);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (E *> IO) = (93.19:128.60:204.26, 73.87:100.96:159.02, 101.03:130.73:191.44, 93.19:128.60:204.26, 89.06:111.53:157.32, 73.87:100.96:159.02);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (E *> IO) = (123.08:166.26:256.44, 87.69:120.29:188.72, 101.14:130.87:194.03, 123.08:166.26:256.44, 89.03:111.23:157.55, 87.69:120.29:188.72);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (I *> IO) = (119.27:163.10:255.48, 128.38:168.21:251.81);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (I *> IO) = (130.64:177.60:276.23, 136.99:180.18:271.49);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (I *> IO) = (99.28:135.76:214.05, 94.13:127.43:199.08);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (I *> IO) = (121.01:163.28:253.05, 104.55:142.35:222.44);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (I *> IO) = (99.52:135.95:214.08, 96.47:129.82:201.42);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (I *> IO) = (117.63:159.05:247.14, 107.35:145.09:225.05);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (I *> IO) = (100.49:137.35:216.47, 91.71:124.70:195.66);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (I *> IO) = (127.65:171.60:264.14, 103.94:142.06:222.64);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (I *> IO) = (103.05:140.84:221.50, 103.81:138.58:213.27);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (I *> IO) = (118.67:160.77:250.11, 114.39:153.29:236.10);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (I *> IO) = (99.88:136.59:215.33, 92.95:126.17:197.63);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (I *> IO) = (124.91:168.16:259.57, 104.79:142.99:223.81);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (I *> IO) = (98.89:135.12:212.95, 93.72:126.79:197.83);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (I *> IO) = (120.46:162.50:251.65, 105.87:143.83:224.15);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (I *> IO) = (101.81:139.07:218.98, 91.78:124.99:196.41);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (I *> IO) = (131.69:176.79:271.27, 105.27:144.10:225.99);
   endspecify
`endprotect
endmodule
`endcelldefine


//-- FTC standard cell revision 1.1 --//
`resetall
`timescale 10ps/1ps
`celldefine
module ZMA2GSD(O, I, IO, E, E2, E4, E8, SR, PU, PD, SMT);
   output O;
   input I, E, E2, E4, E8, SR, PU, PD, SMT;
   inout IO;

//Function Block
`protect
   // Avoide MIPD
   buf b1 (E2_,E2);
   buf b2 (E4_,E4);
   buf b3 (E8_,E8);
   buf b4 (SR_,SR);
   buf b5 (SMT_,SMT);

   pullup_down_keep_IO g1 (IO, I, E, PU, PD);
   buf    g2 (O, IO);

//Specify Block
   specify

      //  Module Path Delay
      if (SMT == 0) (IO *> O) = (41.94:56.10:83.30, 31.91:41.94:59.93);
      if (SMT == 1) (IO *> O) = (45.34:59.22:85.89, 40.48:49.20:66.84);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (E *> IO) = (107.42:148.21:233.38, 108.32:141.10:210.44, 85.26:111.01:166.87, 107.42:148.21:233.38, 64.52:81.25:116.95, 108.32:141.10:210.44);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (E *> IO) = (118.55:162.27:253.70, 116.32:152.19:227.31, 85.41:111.37:167.53, 118.55:162.27:253.70, 64.65:81.48:117.56, 116.32:152.19:227.31);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (E *> IO) = (86.71:119.75:190.37, 73.74:99.88:156.00, 93.58:120.92:179.89, 86.71:119.75:190.37, 81.75:101.77:144.13, 73.74:99.88:156.00);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (E *> IO) = (107.78:146.31:227.95, 83.82:114.20:178.25, 93.69:121.10:180.09, 107.78:146.31:227.95, 81.84:102.35:144.25, 83.82:114.20:178.25);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (E *> IO) = (87.08:120.15:190.81, 75.65:101.50:157.04, 91.30:118.14:176.23, 87.08:120.15:190.81, 75.02:93.29:132.28, 75.65:101.50:157.04);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (E *> IO) = (104.74:142.57:222.80, 85.71:115.60:178.77, 91.43:118.39:176.57, 104.74:142.57:222.80, 75.04:93.47:132.76, 85.71:115.60:178.77);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (E *> IO) = (87.86:121.19:192.52, 70.74:96.34:151.27, 95.56:123.32:183.07, 87.86:121.19:192.52, 85.43:106.94:150.63, 70.74:96.34:151.27);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (E *> IO) = (113.90:153.93:238.05, 82.46:112.80:176.65, 95.65:123.48:183.25, 113.90:153.93:238.05, 85.46:106.86:150.80, 82.46:112.80:176.65);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (E *> IO) = (90.69:125.09:198.29, 83.14:110.56:169.12, 87.87:114.00:170.62, 90.69:125.09:198.29, 71.19:88.79:126.11, 83.14:110.56:169.12);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (E *> IO) = (105.80:144.31:225.82, 92.90:124.14:190.20, 87.99:114.24:171.00, 105.80:144.31:225.82, 71.20:88.85:126.62, 92.90:124.14:190.20);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (E *> IO) = (87.21:120.37:191.30, 72.14:98.02:153.57, 94.10:121.59:180.76, 87.21:120.37:191.30, 83.75:104.73:147.73, 72.14:98.02:153.57);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (E *> IO) = (111.19:150.52:233.51, 83.49:114.00:178.28, 94.19:121.74:180.91, 111.19:150.52:233.51, 83.89:104.97:148.01, 83.49:114.00:178.28);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (E *> IO) = (86.31:119.09:189.22, 72.62:98.08:152.83, 92.13:119.15:177.54, 86.31:119.09:189.22, 78.16:97.36:137.79, 72.62:98.08:152.83);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (E *> IO) = (107.05:145.30:226.25, 83.83:113.74:176.88, 92.24:119.36:177.80, 107.05:145.30:226.25, 78.14:97.84:138.17, 83.83:113.74:176.88);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (E *> IO) = (89.05:122.71:194.68, 70.51:96.21:151.33, 95.95:123.83:183.73, 89.05:122.71:194.68, 87.28:108.59:153.58, 70.51:96.21:151.33);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (E *> IO) = (117.48:158.50:244.29, 83.37:114.20:178.97, 96.04:123.97:183.87, 117.48:158.50:244.29, 87.10:108.95:153.72, 83.37:114.20:178.97);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 0) (I *> IO) = (117.44:160.60:251.47, 125.89:164.70:246.60);
      if (E2 == 0 && E4 == 0 && E8 == 0 && SR == 1) (I *> IO) = (128.55:174.71:271.72, 133.87:175.90:264.62);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 0) (I *> IO) = (96.78:132.27:208.48, 91.34:123.52:192.86);
      if (E2 == 0 && E4 == 0 && E8 == 1 && SR == 1) (I *> IO) = (117.71:158.76:246.01, 101.14:137.58:214.89);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 0) (I *> IO) = (97.14:132.66:208.87, 93.07:125.00:193.75);
      if (E2 == 0 && E4 == 1 && E8 == 0 && SR == 1) (I *> IO) = (114.67:154.99:240.78, 103.10:139.10:215.53);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 0) (I *> IO) = (97.82:133.65:210.56, 88.57:120.24:188.51);
      if (E2 == 0 && E4 == 1 && E8 == 1 && SR == 1) (I *> IO) = (123.85:166.42:256.19, 99.95:136.41:213.64);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 0) (I *> IO) = (100.71:137.58:216.35, 100.63:134.19:205.31);
      if (E2 == 1 && E4 == 0 && E8 == 0 && SR == 1) (I *> IO) = (115.74:156.74:243.80, 110.33:147.76:227.10);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 0) (I *> IO) = (97.21:132.84:209.37, 89.91:121.87:190.75);
      if (E2 == 1 && E4 == 0 && E8 == 1 && SR == 1) (I *> IO) = (121.13:162.99:251.61, 100.95:137.58:215.22);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 0) (I *> IO) = (96.30:131.54:207.24, 90.14:121.71:189.71);
      if (E2 == 1 && E4 == 1 && E8 == 0 && SR == 1) (I *> IO) = (116.97:157.73:244.26, 101.30:137.36:213.84);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 0) (I *> IO) = (98.97:135.12:212.70, 88.46:120.24:188.79);
      if (E2 == 1 && E4 == 1 && E8 == 1 && SR == 1) (I *> IO) = (127.45:171.02:262.48, 100.93:137.93:216.16);
   endspecify
`endprotect
endmodule
`endcelldefine



// END_OF_CELL

///////////////////////////////////////////////
// Cell Name : dffrb_pri
// Cell Type : Primitive
// Revised on: Fri May 6 17:03:26 1998
///////////////////////////////////////////////
module dffrb_pri (out,d,rb,clk);
 output out;
 input d,clk,rb;

`protect
  not  a1 (p1_s, d);
  pmos #1 p1 (n1_s, p1_s, clk);
  not  a2 (n2_s, n1_s); 
  nand  a3 (n1_d, n2_s, rb);
  nmos n1 (n1_tmp, n1_d, clk);
  buf  (pull1, pull0)  b1 (n1_s, n1_tmp);
  nmos n2 (out, n2_s, clk);
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : dffrsb_udp
// Cell Type : Primitive
// Revised on: 11/02 2001
// Version   : 1.5
///////////////////////////////////////////////

primitive   dffrsb_udp(q, d, ck, rb, sb, flag);
   output q;
   input d, ck, rb, sb, flag;
   reg q;


`protect
   table
//     D    CK    RB    SB  FLAG :    Qt :  Qt+1
       1  (01)     1     1     ? :     ? :     1;// clocked  data
       1  (01)     1     x     ? :     ? :     1;// pessimism

       1     ?     1     x     ? :     1 :     1;// pessimism
       0     x     1     x     ? :     1 :     x;// pessimism
       0     b     1     x     ? :     1 :     1;// pessimism
       x     ?     1     x     ? :     1 :     x;// pessimism
       x     ?     1     x     ? :     0 :     x;// pessimism
       x     ?     1     x     ? :     x :     x;// pessimism


       0  (01)     1     1     ? :     ? :     0;
       0  (01)     x     1     ? :     ? :     0;// pessimism

       1     x     x     1     ? :     0 :     x;// pessimism
       1     b     x     1     ? :     0 :     0;// pessimism
       0     ?     x     1     ? :     0 :     0;// pessimism
       x     ?     x     1     ? :     0 :     x;// pessimism
       x     ?     x     1     ? :     1 :     x;// pessimism
       x     ?     x     1     ? :     x :     x;// pessimism

       1  (x1)     1     ?     ? :     1 :     1;// reducing pessimism
       0  (x1)     ?     1     ? :     0 :     0;
       1  (0x)     1     ?     ? :     1 :     1;
       0  (0x)     ?     1     ? :     0 :     0;
       ?     ?     0     1     ? :     ? :     0;// asynchronous clear
       ?     ?     1     0     ? :     ? :     1;// asynchronous   set
       ?     ?     0     0     ? :     ? :     0;// preset override
       ?     ?     0     x     ? :     ? :     0;// pessimism
       ?  (?0)     1     1     ? :     ? :     -;// ignore falling clock

       // deal with clk "x"
       1  (1x)     1     ?     ? :     1 :     1;
       0  (1x)     ?     1     ? :     0 :     0;
       *     b     1     1     ? :     ? :     -;// ignore  data edges

       ?     b  (?1)     1     ? :     ? :     -;// ignore   the edges    on
       ?     b     1  (?1)     ? :     ? :     -;//   set   and clear
       0     x  (?1)     1     ? :     ? :     -;
       1     x     1  (?1)     ? :     ? :     -;
       ?     ?     ?     ?     * :     ? :     x;
   endtable
`endprotect
endprimitive
///////////////////////////////////////////////
// Cell Name : dffsb_pri
// Cell Type : Primitive
// Revised on: Fri May 6 17:03:26 1998
///////////////////////////////////////////////
module dffsb_pri (out,d,sb,clk);
 output out;
 input d,clk,sb;

`protect
  not  a1 (p1_s, d);
  pmos #1 p1 (n1_s, p1_s, clk);
  nand  a2 (n2_s, n1_s, sb);
  not  a3 (n1_d, n2_s);
  nmos n1 (n1_tmp, n1_d, clk);
  buf  (pull1, pull0)  b1 (n1_s, n1_tmp);
  nmos n2 (out, n2_s, clk);
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : dlhrb_udp
// Cell Type : Primitive
// Version   : 1.1
// Date      : 10/02 2001
// Reason    :
//      1.1  : Initial.
///////////////////////////////////////////////

primitive   dlhrb_udp (q, d, ck, rb, flag);

   output q;
   reg q;
   input d, ck, rb, flag;

`protect
   table
//     D    CK    RB  FLAG :   Qtn : Qtn+1

       ?   (?0)    ?    ?  :    ?  :   -; // Latch state
       *    0      1    ?  :    ?  :   -; 

      (?0)  1      1    ?  :    ?  :   0; // Latch data
       0   (?1)    1    ?  :    ?  :   0;
       0    1     (?1)  ?  :    ?  :   0;

      (?1)  1      1    ?  :    ?  :   1; // Latch data
       1   (?1)    1    ?  :    ?  :   1;
       1    1     (?1)  ?  :    ?  :   1;

     (?1)   x      1    ?  :    1  :   1;
       1   (?x)    1    ?  :    1  :   1;
 
     (?0)   x      1    ?  :    0  :   0;
       0   (?x)    1    ?  :    0  :   0;

       ?    ?      0    ?  :    ?  :   0; // Asyn. reset

      (?0)  1      x    ?  :    ?  :   0;
       0  (?1)     x    ?  :    ?  :   0;
       0    1     (?x)  ?  :    ?  :   0;

      (?0)  ?      x    ?  :    0  :   0;
       0    *      x    ?  :    0  :   0;
       0    ?      *    ?  :    0  :   0;
       *    0      x    ?  :    0  :   0;
       ?    0     (?x)  ?  :    0  :   0;

       ?    0     (?1)  ?  :    ?  :   -;

       ?    ?      ?     * :    ? :    x; // Timing violation toggle
   endtable
`endprotect
endprimitive

///////////////////////////////////////////////
// Cell Name : dlhrsb_udp
// Cell Type : Primitive
// Version   : 1.1
// Date      : 10/02 2001
// Reason    :
//      1.1  : Initial.
///////////////////////////////////////////////

primitive dlhrsb_udp (q, d, ck, rb, sb, flag);
   output q;
   reg q;
   input d, ck, rb, sb, flag;

`protect
   table
//     D    CK    RB   SB   FLAG :   Qtn : Qtn+1

       ?   (?0)    1    1     ?  :    ?  :   -; //Latch state
       *    0      1    1     ?  :    ?  :   -;

      (?0)  1      1    1     ?  :    ?  :   0; //Latch data
       0   (?1)    1    1     ?  :    ?  :   0;
       0    1     (?1)  1     ?  :    ?  :   0;
       0    1      1  (?1)    ?  :    ?  :   0;

      (?1)  1      1    1     ?  :    ?  :   1; //Latch data
       1   (?1)    1    1     ?  :    ?  :   1;
       1    1     (?1)  1     ?  :    ?  :   1;
       1    1      1  (?1)    ?  :    ?  :   1;
 
     (?1)   x      1    1     ?  :    1  :   1;
       1   (?x)    1    1     ?  :    1  :   1;

     (?0)   x      1    1     ?  :    0  :   0;
       0   (?x)    1    1     ?  :    0  :   0;

       ?    ?      0    ?     ?  :    ?  :   0; //Asyn. reset
       ?    ?      1    0     ?  :    ?  :   1; //Asyn. preset

      (?0)  1      x    1     ?  :    ?  :   0;
       0  (?1)     x    1     ?  :    ?  :   0;
       0    1     (?x)  1     ?  :    ?  :   0;
       0    1      x   (?1)   ?  :    ?  :   0;

      (?0)  ?      x    1     ?  :    0  :   0;
       0    *      x    1     ?  :    0  :   0;
       0    ?      *    1     ?  :    0  :   0;
       0    x      x   (?1)   ?  :    0  :   0;
       *    0      x    1     ?  :    0  :   0;

      (?1)  1      1    x     ?  :    ?  :   1;
       1  (?1)     1    x     ?  :    ?  :   1;
       1    1      1   (?x)   ?  :    ?  :   1;
       1    1     (?1)  x     ?  :    ?  :   1;

      (?1)  ?      1    x     ?  :    1  :   1;
       1    *      1    x     ?  :    1  :   1;
       1    ?      1    *     ?  :    1  :   1;
       1    x     (?1)  x     ?  :    1  :   1;
       *    0      1    x     ?  :    1  :   1;

       ?    0     (?1)  1     ?  :    ?  :   -;
       ?    0      1   (?1)   ?  :    ?  :   -;
       
       ?    ?      ?    ?     *  :    ?  :   x; //Timing violation toggle
   endtable
`endprotect
endprimitive
///////////////////////////////////////////////
// Cell Name : dlhsb_udp
// Cell Type : Primitive
// Version   : 1.1
// Date      : 10/02 2001
// Reason    :
//      1.1  : Initial.
///////////////////////////////////////////////

primitive   dlhsb_udp (q, d, ck, sb, flag);

   output q;
   reg q;
   input d, ck, sb, flag;
`protect
   table
//     D    CK    SB  FLAG :   Qtn : Qtn+1

       ?   (?0)    ?    ?  :    ?  :   -; // Latch state
       *    0      1    ?  :    ?  :   -; 

      (?0)  1      1    ?  :    ?  :   0; // Latch data
       0   (?1)    1    ?  :    ?  :   0;
       0    1     (?1)  ?  :    ?  :   0;

      (?1)  1      1    ?  :    ?  :   1; // Latch data
       1   (?1)    1    ?  :    ?  :   1;
       1    1     (?1)  ?  :    ?  :   1;

     (?1)   x      1    ?  :    1  :   1;
       1   (?x)    1    ?  :    1  :   1;

     (?0)   x      1    ?  :    0  :   0;
       0   (?x)    1    ?  :    0  :   0;

       ?    ?      0    ?  :    ?  :   1; // Asyn. preset
 
      (?1)  1      x    ?  :    ?  :   1;
       1  (?1)     x    ?  :    ?  :   1;
       1    1     (?x)  ?  :    ?  :   1;

      (?1)  ?      x    ?  :    1  :   1;
       1    *      x    ?  :    1  :   1;
       1    ?      *    ?  :    1  :   1;
       *    0      x    ?  :    1  :   1;
       ?    0     (?x)  ?  :    1  :   1;

       ?    0     (?1)  ?  :    ?  :   -;

       ?    ?      ?     * :    ? :    x; // Timing violation toggle

   endtable
`endprotect
endprimitive
///////////////////////////////////////////////
// Cell Name : jkffrsb_udp
// Cell Type : Primitive
// Version   : 1.3
// Date      : 11/02 2001
// Reason    :
//      1.3  : modify protection method.
//      1.2  : Deal with unknown ck.
//      1.1  : Initial.
///////////////////////////////////////////////

primitive   jkffrsb_udp (q, j, k, ck, rb, sb, flag);

// JK FLIP FLOP, WITH RB/SB /STANDARD DRIVE
   output q;
   reg q;
   input j,k,ck,rb,sb,flag;


`protect
   table
//     J     K    CK    RB    SB  FLAG :   Qtn : Qtn+1
       0     0     r     1     1     ? :     ? :     -;// Output retains the
                                                       // current state if both
                                                       // J and K are 0.
       0     1     r     ?     1     ? :     ? :     0;// Clocked J & K.
       1     0     r     1     ?     ? :     ? :     1;
       1     1     r     1     ?     ? :     0 :     1;// Clocked toggle.
       1     1     r     ?     1     ? :     1 :     0;

       1     x     r     1     1     ? :     0 :     1;// toggle previous one
       x     1     r     1     1     ? :     1 :     0;// toggle previous one
       ?     1     r     x     1     ? :     1 :     0;//pessimism
       1     ?     r     1     x     ? :     0 :     1;

       ?     0     r     1     ?     ? :     1 :     1;// conflict statements
       0     ?     r     ?     1     ? :     0 :     0;// conflict statement

       ?     ?     f     ?     ?     ? :     ? :     -;// Output state is
						       // insensitive to the
						       // falling edge of
						       // the clock.
       0     0  (x1)     1     1     ? :     ? :     -;// possible clocked JK
       0     ?  (x1)     ?     1     ? :     0 :     0;
       ?     0  (x1)     1     ?     ? :     1 :     1;

       0     0  (?x)     1     1     ? :     ? :     -;
       0     ?  (?x)     ?     1     ? :     0 :     0;
       ?     0  (?x)     1     ?     ? :     1 :     1;

       0     ?     ?     x     1     ? :     0 :     0;//pessimism
       ?     0     ?     1     x     ? :     1 :     1;//pessimism

       // deal with clk "x"
       *     ?     b     1     1     ? :     ? :     -;
       *     0     x     1     1     ? :     1 :     1;
       ?     *     b     1     1     ? :     ? :     -;
       0     *     x     1     1     ? :     0 :     0;
						       
       ?     ?     ?     0     ?     ? :     ? :     0;// Clear.
       ?     ?     ?     1     0     ? :     ? :     1;// Set.

       ?     ?  (?0)     1     1     ? :     ? :     -;// ignore falling clock.

       // deal with clk "x"
       ?     ?     b  (?1)     1     ? :     ? :     -;
       0     0     x  (?1)     1     ? :     ? :     -;
       0     ?     x  (?1)     1     ? :     0 :     0;
       ?     ?     b     1  (?1)     ? :     ? :     -;
       0     0     x     1  (?1)     ? :     ? :     -;
       ?     0     x     1  (?1)     ? :     1 :     1;

       ?     ?     ?     ?     ?     * :     ? :     x;
   endtable
`endprotect
endprimitive
///////////////////////////////////////////////
// Cell Name : mux2_udp
// Cell Type : Primitive
// Revised on: Wed Feb 26 17:03:31 1992
///////////////////////////////////////////////
primitive   mux2_udp (q, a, b, sl);
   output q;
   input a, b, sl;
   // FUNCTION : TWO TO ONE MULTIPLEXER
`protect
   table
   // A B SL : Q
      0 0 ?  : 0 ;
      1 1 ?  : 1 ;
      0 ? 0  : 0 ;
      1 ? 0  : 1 ;
      ? 0 1  : 0 ;
      ? 1 1  : 1 ;
   endtable
`endprotect
endprimitive


///////////////////////////////////////////////
// Cell Name : mux3_udp
// Cell Type : Primitive
// Revised on: Wed Feb 26 17:03:31 1992
///////////////////////////////////////////////
primitive   mux3_udp (Y, D0, D1, D2, S0, S1);
   input D0, D1, D2, S0, S1;
   output Y;
   // FUNCTION : THREE TO ONE MULTIPLEXER WITH 2 SELECT CONTROLS
`protect
   table
   // D0 D1 D2 S0 S1 : Y
       0  ?  ?  0  0 : 0 ;
       1  ?  ?  0  0 : 1 ;
       ?  0  ?  1  0 : 0 ;
       ?  1  ?  1  0 : 1 ;
       ?  ?  0  ?  1 : 0 ;
       ?  ?  1  ?  1 : 1 ;
       0  0  0  ?  ? : 0 ; //pessimism
       1  1  1  ?  ? : 1 ;
       0  0  ?  ?  0 : 0 ; //pessimism
       1  1  ?  ?  0 : 1 ; //pessimism
       0  ?  0  0  ? : 0 ;
       1  ?  1  0  ? : 1 ;
       ?  0  0  1  ? : 0 ;
       ?  1  1  1  ? : 1 ;
   endtable
`endprotect
endprimitive


///////////////////////////////////////////////
// Cell Name : mux4_udp
// Cell Type : Primitive
// Revised on: Wed Feb 26 17:03:35 1992
///////////////////////////////////////////////
primitive   mux4_udp (y, d0, d1, d2, d3, s0, s1);
   input d0, d1, d2, d3, s0, s1;
   output y;
   // FUNCTION : FOUR TO ONE MULTIPLEXER WITH 2 SELECT CONTROLS
`protect
   table
   // D0 D1 D2 D3 S0 S1 : Y
      0   ?  ?  ?  0  0 : 0 ;
      1   ?  ?  ?  0  0 : 1 ;
      ?   0  ?  ?  1  0 : 0 ;
      ?   1  ?  ?  1  0 : 1 ;
      ?   ?  0  ?  0  1 : 0 ;
      ?   ?  1  ?  0  1 : 1 ;
      ?   ?  ?  0  1  1 : 0 ;
      ?   ?  ?  1  1  1 : 1 ;
      0   0  0  0  ?  ? : 0 ;
      1   1  1  1  ?  ? : 1 ;
      0   0  ?  ?  ?  0 : 0 ;
      1   1  ?  ?  ?  0 : 1 ;
      ?   ?  0  0  ?  1 : 0 ;
      ?   ?  1  1  ?  1 : 1 ;
      0   ?  0  ?  0  ? : 0 ;
      1   ?  1  ?  0  ? : 1 ;
      ?   0  ?  0  1  ? : 0 ;
      ?   1  ?  1  1  ? : 1 ;
   endtable
`endprotect
endprimitive


///////////////////////////////////////////////
// Cell Name : pulldown_IO
// Cell Type : Primitive
// Version   : 1.3
// Revised on: 8/20 '02
///////////////////////////////////////////////
module  pulldown_IO (io, i, e);

  input i, e;
  inout io;

`protect
`ifdef ftc_gatelevel
  tri0 io;

  bufif1 (io, i, e);
`else

  `ifdef ftc_verify
     parameter THZ   = 4;
  `else
     parameter THZ   = 400000;
  `endif

   supply1 vcc;
   reg  io_e, pre;
   wire e_tmp, io_i, ne;
   wire io_i_tmp;

   event EventTHZ;

// Function

   buf    g1 (e_tmp, e);
   bufif1 g2 (io_i, i, e_tmp);
   not    g3 (ne,   e_tmp);
   rnmos  g4 (io_i_tmp, io_e, ne);  //-- pull level
   rnmos  g5 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
   nmos   g6 (io,   io_i, vcc);

   always @(e_tmp)
   begin
     if (e_tmp == 1'b1)
     begin
       disable BlockTHZ;
     end
     else if (e_tmp == 1'b0)
     begin
       if (io == 1'b0)
         io_e <= 1'b0;
       else
       begin
         io_e <= 1'bz;
       end
     end
   end

   always @(io)
   begin
     if (e_tmp ==1'b0)
     begin
       if (io===1'b0)
       begin
         disable BlockTHZ;
         io_e = 1'b0;
       end
       else if (io===1'b1)
       begin
         disable BlockTHZ;
         io_e = 1'bz;
       end
       else if (io===1'bz)
       begin
         disable BlockTHZ;
         io_e = 1'bz;
         #0 ->EventTHZ;
       end
     end
   end

   always @(EventTHZ)
   begin:BlockTHZ
     io_e = #THZ 1'b0;
   end
`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_IO
// Cell Type : Primitive
// Version   : 1.4
// Revised on: 3/19 '03
///////////////////////////////////////////////
module  pullup2_down_IO (io, i, e, pu1, pu2, pd);

   input i, e, pu1, pu2, pd;
   inout io;
   wire io1_tmp;
   
`protect

`ifdef ftc_gatelevel

`else

`ifdef ftc_verify
   parameter THZ   = 4;
`else
   parameter THZ   = 399999.9;
`endif

   supply1 vcc;
   reg  io_e;
   wire io_i, ne;
   wire e_tmp, pu1_tmp, pu2_tmp, pd_tmp;
   wire io_i_pull, io_i_weak, io_i_med;
   wire str_ctl, io_i_tmp;

   reg io_pre, ioe_ok;

   event Event_PU,
         Event_PD,
         Event_DisableAll;

   buf  g1 (pu1_tmp, pu1);
   buf  g2 (pu2_tmp, pu2);
   buf  g3 (pd_tmp, pd);
   buf  g4 (e_tmp, e);

   bufif1 g5 (io_i, i, e_tmp);
   not    g6 (ne, e_tmp);
   rnmos  g7 (io_i_pull, io_e, ne);  //-- pull level
   rnmos  g8 (io_i_weak, io_i_pull, vcc);  //-- weak level
   rnmos  g9 (io_i_med, io_i_weak, vcc);  //-- medium level
   nmos   ga (io_i, io_i_tmp, vcc);     
   nmos #0.1 gb (io,   io_i, vcc);

   // assign str_ctl = (!pd_tmp) & (!pu1_tmp) & pu2_tmp;
   not 	  ga1 (pd_tmp_bar, pd_tmp);
   not    ga2(pu1_tmp_bar, pu1_tmp);
   and    ga3 (str_ctl, pd_tmp_bar, pu1_tmp_bar, pu2_tmp);
   not    ga4 (str_ctl_bar, str_ctl);
   // assign io_i_tmp = (str_ctl)? io_i_med : io_i_pull;
   nmos   ga5 (io_i_tmp, io_i_pull, str_ctl_bar);     
   nmos   ga6 (io_i_tmp, io_i_med, str_ctl);        
   // assign pu_tmp = pu1_tmp & pu2_tmp;
   or     ga7 (pu_tmp, pu1_tmp, pu2_tmp);
      
   always @(e_tmp or pu_tmp or pd_tmp)
   begin
     ->Event_DisableAll;
     if (e_tmp == 1'b0)
     begin
       case ({pu_tmp,pd_tmp})
         2'b10 :
         begin
           if (io == 1'b1)
             io_e <= 1'b1;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
	       #0 ->Event_PU;
             end 
           end
         end
         2'b01 :
         begin
           if (io == 1'b0)
             io_e <= 1'b0;
           else
           begin
             if (io_e !== 1'bz)
             io_e <= 1'bz;
             else
             begin
               #0 ->Event_PD;
             end
           end
         end
         2'b00,
         2'b11 :
         begin
           io_e <= 1'bz; 
         end
         default : 
	 begin
	   io_e <= 1'bx; 	 
	 end
       endcase 
     end
   end

   always @(io)
   begin 
     if (e_tmp==1'b0)
     begin
       case ({pu_tmp,pd_tmp})
         2'b10 :
         begin
           if (io===1'b1)
           begin
             disable BlockPU;
             io_e = 1'b1;
           end
           else if (io===1'b0)
           begin
             disable BlockPU;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPU;
             io_e = 1'bz;
             #0 ->Event_PU;
           end
         end
         2'b01 :
         begin
           if (io===1'b0)
           begin
             disable BlockPD;
             io_e = 1'b0;
           end
           else if (io===1'b1)
           begin
             disable BlockPD;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPD;
             io_e = 1'bz;
             #0 ->Event_PD;
           end
         end
         2'b00,
         2'b11 :
         begin
           // do nothing;
         end
         default : 
         begin
	   io_e = 1'bx; 	 
         end
       endcase
     end
   end

   always @(Event_DisableAll)
   begin:BlockDisableAll
     disable BlockPU;
     disable BlockPD;
   end

   always @(Event_PU)
   begin:BlockPU
     io_e = #THZ 1'b1;
   end

   always @(Event_PD)
   begin:BlockPD
     io_e = #THZ 1'b0;
   end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_IO
// Cell Type : Primitive
// Version   : 1.3
// Revised on: 8/20 '02
///////////////////////////////////////////////
module  pullup_IO (io, i, e);

  input i, e;
  inout io;

`protect

`ifdef ftc_gatelevel
  tri1 io;

  bufif1 (io, i, e);
`else

  `ifdef ftc_verify
     parameter THZ   = 4;
  `else
     parameter THZ   = 400000;
  `endif

   supply1 vcc;
   reg  io_e, pre;
   wire e_tmp, io_i, ne;
   wire io_i_tmp;

   event EventTHZ;

// Function

   buf      g1 (e_tmp, e);
   bufif1   g2 (io_i, i, e_tmp);
   not      g3 (ne,   e_tmp);
   rnmos    g4 (io_i_tmp, io_e, ne);  //-- pull level
   rnmos    g5 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
   nmos     g6 (io,   io_i, vcc);

   always @(e_tmp)
   begin
     if (e_tmp == 1'b1)
     begin
       disable BlockTHZ;
     end
     else if (e_tmp == 1'b0)
     begin
       if (io == 1'b1)
         io_e <= 1'b1;
       else
       begin
         io_e <= 1'bz;
       end
     end
   end

   always @(io)
   begin
     if (e_tmp==1'b0)
     begin
       if (io===1'b1)
       begin
         disable BlockTHZ;
         io_e = 1'b1;
       end
       else if (io===1'b0)
       begin
         disable BlockTHZ;
         io_e = 1'bz;
       end
       else if (io===1'bz)
       begin
         disable BlockTHZ;
         io_e = 1'bz;
         #0 ->EventTHZ;
       end
     end
   end

   always @(EventTHZ)
   begin:BlockTHZ
     io_e = #THZ 1'b1;
   end
`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_IO
// Cell Type : Primitive
// Version   : 1.4
// Revised on: 3/19 '03
///////////////////////////////////////////////
module  pullup_down_IO (io, i, e, pu, pd);

   input i, e, pu, pd;
   inout io;
   wire io1_tmp;

`protect

`ifdef ftc_gatelevel
   supply1 vcc;

   bufif1 g1(io1, i, e);
   not    g2(pub, pu);
   not    g3(pdb, pd);
   and    g4(pupd, pu, pd);
   and    g5(pu_pd_, pub, pdb);
   or     g6(pcon, pupd, pu_pd_);
   or     g7(pull_down1, pdb, pu);
   rpmos  g8(io1_tmp, pull_down1, pcon);  //-- pull level
   rnmos  g9(io1, io1_tmp, vcc);  //-- added for down scale to weak level   
   nmos   ga(io,io1,vcc);
`else

`ifdef ftc_verify
   parameter THZ   = 4;
`else
   parameter THZ   = 399999.9;
`endif

  supply1 vcc;
  reg  io_e;
  wire io_i, ne;
  wire e_tmp,pu_tmp,pd_tmp;
  wire io_i_tmp;

  event Event_PU,
        Event_PD,
        Event_DisableAll;

  buf  g1 (pu_tmp, pu);
  buf  g2 (pd_tmp, pd);
  buf  g3 (e_tmp, e);

  bufif1  g4 (io_i, i, e_tmp);
  not     g5 (ne, e_tmp);
  rnmos   g6 (io_i_tmp, io_e, ne);  //-- pull level
  rnmos   g7 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
  nmos #0.1 g8 (io,   io_i, vcc);

  always @(e_tmp or pu_tmp or pd_tmp)
  begin
    ->Event_DisableAll;
    if (e_tmp == 1'b0)
    begin
      case ({pu_tmp,pd_tmp})
        2'b10 :
        begin
          if (io == 1'b1)
            io_e <= 1'b1;
          else
          begin
            if (io_e !== 1'bz)
              io_e <= 1'bz;
            else
            begin
	      #0 ->Event_PU;
            end 
          end
        end
        2'b01 :
        begin
          if (io == 1'b0)
            io_e <= 1'b0;
          else
          begin
            if (io_e !== 1'bz)
              io_e <= 1'bz;
            else
            begin
              #0 ->Event_PD;
            end
          end
        end
        2'b00,
        2'b11 :
        begin
          io_e <= 1'bz; 
        end
        default : 
	begin
          io_e <= 1'bx; 	 
	end
      endcase 
    end
  end

  always @(io)
  begin 
    if (e_tmp==1'b0)
    begin
      case ({pu_tmp,pd_tmp})
        2'b10 :
        begin
          if (io===1'b1)
          begin
            disable BlockPU;
            io_e = 1'b1;
          end
          else if (io===1'b0)
          begin
            disable BlockPU;
            io_e = 1'bz;
          end
          else if (io===1'bz)
          begin
            disable BlockPU;
            io_e = 1'bz;
            #0 ->Event_PU;
          end
        end
        2'b01 :
        begin
          if (io===1'b0)
          begin
            disable BlockPD;
            io_e = 1'b0;
          end
          else if (io===1'b1)
          begin
            disable BlockPD;
            io_e = 1'bz;
          end
          else if (io===1'bz)
          begin
            disable BlockPD;
            io_e = 1'bz;
            #0 ->Event_PD;
          end
        end
        2'b00,
        2'b11 :
        begin
          // do nothing;
        end
        default : 
        begin
	  io_e = 1'bx; 	 
        end
      endcase
    end
  end

  always @(Event_DisableAll)
  begin:BlockDisableAll
    disable BlockPU;
    disable BlockPD;
  end

  always @(Event_PU)
  begin:BlockPU
    io_e = #THZ 1'b1;
  end

  always @(Event_PD)
  begin:BlockPD
    io_e = #THZ 1'b0;
  end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_IO_IEO
// Cell Type : Primitive
// Version   : 1.2
// Revised on: 11/18 '03
///////////////////////////////////////////////
module  pullup_down_IO_IEO (io, o, i, e, ie, pu, pd);

   input i, e, ie, pu, pd;
   inout io; 
   output o;
   wire io1_tmp;

`protect
`ifdef ftc_gatelevel
`else

`ifdef ftc_verify
   parameter THZ   = 4;
`else
   parameter THZ   = 399999.9;
`endif

  supply1 vcc;
  reg  io_e, io_e1;
  wire io_i, ne, nie;
  wire e_tmp, ie_tmp, pu_tmp, pd_tmp;
  wire i0, i1;
  wire io_i_tmp;

  event Event_PU,
        Event_PD,
        Event_DisableAll,
        Event_PU1,
        Event_PD1,
        Event_DisableAll1;

  buf  b1 (pu_tmp, pu);
  buf  b2 (pd_tmp, pd);
  buf  b3 (e_tmp, e);
  buf  b4 (ie_tmp, ie);
  and  g4 (pu_tmp1, ie, pu_tmp);

  bufif1  g5 (io_i, i, e_tmp);
  not     g6 (ne, e_tmp);
  not     g7 (nie, ie_tmp);
  rnmos   g8 (io_i_tmp, io_e, ne);  //-- pull level
  rnmos   g9 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
  nmos #0.1 ga (io,   io_i, vcc);
  //--- mux2 ----
  and gb (i0, io_e1, nie);
  and gc (i1, io, ie_tmp);
  or #0.1 gd (o, i0, i1);

  always @(ie_tmp or pu_tmp or pd_tmp)
  begin
    ->Event_DisableAll1;
    if (ie_tmp === 1'b0)
    begin
     case (pu_tmp)
        1'b1:
        begin
          if (pd_tmp === 1'b0)
          begin
            if (o === 1'b1)
              io_e1 <= 1'b1;
            else
            begin
              if (io_e1 !== 1'bz)
              begin
                io_e1 <= 1'bz;
              end 
              else
              begin
	        #0 ->Event_PU1;
              end 
            end
          end
	  else if (pd_tmp === 1'b1)
            io_e1 <= 1'bz; 
	  else
            io_e1 <= 1'bx; 
        end
        1'b0:
        begin
          io_e1 <= 1'bz; 
        end
        default : 
	begin
          io_e1 <= 1'bx; 	 
	end
      endcase 
    end
  end

  always @(e_tmp or ie_tmp or pu_tmp or pd_tmp)
  begin
    ->Event_DisableAll;
    if (e_tmp === 1'b0)
    begin
      case ({pu_tmp1,pd_tmp})
        2'b10 :
        begin
          if (io === 1'b1)
            io_e <= 1'b1;
          else
          begin
            if (io_e !== 1'bz)
              io_e <= 1'bz;
            else
            begin
	      #0 ->Event_PU;
            end 
          end
        end
        2'b01 :
        begin
          if (pu_tmp === 1'b0)
          begin
            if (io === 1'b0)
              io_e <= 1'b0;
            else
            begin
              if (io_e !== 1'bz)
                io_e <= 1'bz;
              else
              begin
                #0 ->Event_PD;
              end
            end
          end
	  else if (pu_tmp === 1'b1)
            io_e <= 1'bz; 
	  else
            io_e <= 1'bx; 
	end
        2'b00,
        2'b11 :
        begin
          io_e <= 1'bz; 
        end
        default : 
	begin
          io_e <= 1'bx; 	 
	end
      endcase 
    end
  end

  always @(io)
  begin 
    if (e_tmp===1'b0)
    begin
      case ({pu_tmp1,pd_tmp})
        2'b10 :
        begin
          if (io===1'b1)
          begin
            disable BlockPU;
            io_e = 1'b1;
          end
          else if (io===1'b0)
          begin
            disable BlockPU;
            io_e = 1'bz;
          end
          else if (io===1'bz)
          begin
            disable BlockPU;
            io_e = 1'bz;
            #0 ->Event_PU;
          end
        end
        2'b01 :
        begin
          if (pu_tmp === 1'b0)
          begin
            if (io===1'b0)
            begin
              disable BlockPD;
              io_e = 1'b0;
            end
            else if (io===1'b1)
            begin
              disable BlockPD;
              io_e = 1'bz;
            end
            else if (io===1'bz)
            begin
              disable BlockPD;
              io_e = 1'bz;
              #0 ->Event_PD;
            end
          end
	  else if (pu_tmp === 1'b1) 
            io_e <= 1'bz; 
	  else
            io_e <= 1'bx; 
        end
        2'b00,
        2'b11 :
        begin
          // do nothing;
        end
        default : 
        begin
	  io_e = 1'bx; 	 
        end
      endcase
    end
  end

  always @(Event_DisableAll)
  begin:BlockDisableAll
    disable BlockPU;
    disable BlockPD;
  end

  always @(Event_DisableAll1)
  begin:BlockDisableAll1
    disable BlockPU1;
    disable BlockPD1;
  end

  always @(Event_PU)
  begin:BlockPU
    io_e = #THZ 1'b1;
  end

  always @(Event_PU1)
  begin:BlockPU1
   io_e1 = #THZ 1'b1;
  end

  always @(Event_PD)
  begin:BlockPD
    io_e = #THZ 1'b0;
  end

  always @(Event_PD1)
  begin:BlockPD1
    io_e1 = #THZ 1'b0;
  end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_IO_PSCN
// Cell Type : Primitive
// Version   : 1.4
// Revised on: 3/19 '03
///////////////////////////////////////////////
module  pullup_down_IO_PSCN (o, io, i, e, pu, pd, pscn, ieb);

   input i, e, pu, pd, pscn, ieb;
   inout io;
   output o;
   wire io1_tmp;

`protect

`ifdef ftc_gatelevel
   supply1 vcc;

   buf    gb(e_tmp, e);
   buf    gc(pscn_tmp, pscn);
   and    gd(e_pscn, e_tmp, pscn_tmp);
   bufif1 g1(io1, i, e_pscn);
   not    ge(pscnb, pscn_tmp);
   or     gf(pu_tmp, pu, pscnb);
   and    gg(pd_tmp, pd, pscn_tmp);
   not    g2(pub, pu_tmp);
   not    g3(pdb, pd_tmp);
   and    g4(pupd, pu, pd);
   and    g5(pu_pd_, pub, pdb);
   or     g6(pcon, pupd, pu_pd_);
   or     g7(pull_down1, pdb, pu);
   rpmos  g8(io1_tmp, pull_down1, pcon);  //-- pull level
   rnmos  g9(io1, io1_tmp, vcc);  //-- added for down scale to weak level   
   nmos   ga(io,io1,vcc);
   or     gh(o_tmp, io, ieb);
   and    gi(o, o_tmp, pscn_tmp);
   
`else

`ifdef ftc_verify
   parameter THZ   = 4;
`else
   parameter THZ   = 399999.9;
`endif

  supply1 vcc;
  reg  io_e;
  reg o;
  wire io_i, ne;
  wire e_tmp,pu_tmp,pd_tmp;
  wire io_i_tmp;

  event Event_PU,
        Event_PD,
        Event_DisableAll;

  buf  g1 (pu_tmp, pu);
  buf  g2 (pd_tmp, pd);
  buf  g3 (e_tmp, e);
  buf  g4 (pscn_tmp, pscn);
  and  b1 (e_pscn, e_tmp, pscn_tmp);

  bufif1  g5 (io_i, i, e_pscn); //-- when e=0; io_i=HiZ
  not     g6 (ne, e_pscn);
  rnmos   g7 (io_i_tmp, io_e, ne);  //-- pull level;pass io_e to io_i when e=0
  rnmos   g8 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level; i has higher priority than io_e
  nmos #0.1 g9 (io, io_i, vcc);

  always @(io or e_tmp or pu_tmp or pd_tmp or pscn_tmp or ieb)
  begin
    if (pscn_tmp == 1'b0)
      o <= 1'bx;
    else
      o = io | ieb; 
  end

  always @(e_tmp or pu_tmp or pd_tmp or pscn_tmp)
  begin
    ->Event_DisableAll;
    if (pscn_tmp == 1'b0)
    begin
      if (io == 1'b1)
        io_e <= 1'b1;
      else
      begin
        if (io_e !== 1'bz)
          io_e <= 1'bz;
        else
        begin
          #0 ->Event_PU;
        end 
      end
    end
    else
    begin
      if (e_tmp == 1'b0)
      begin
        case ({pu_tmp,pd_tmp,pscn_tmp})
          3'b101 :
          begin
            if (io == 1'b1)
              io_e <= 1'b1;
            else
            begin
              if (io_e !== 1'bz)
                io_e <= 1'bz;
              else
              begin
  	      #0 ->Event_PU;
              end 
            end
          end
          3'b011 :
          begin
            if (io == 1'b0)
              io_e <= 1'b0;
            else
            begin
              if (io_e !== 1'bz)
                io_e <= 1'bz;
              else
              begin
                #0 ->Event_PD;
              end
            end
          end
          3'b001,
          3'b111 :
          begin
            io_e <= 1'bz; 
          end
          default : 
  	  begin
            io_e <= 1'bx; 	 
  	  end
        endcase 
      end
    end
  end

  always @(io)
  begin
    if (pscn_tmp == 1'b0)
    begin
      if (io == 1'b1)
      begin
        disable BlockPU;
        io_e = 1'b1;
      end
      else if (io == 1'b0)
      begin
        disable BlockPU;
        io_e = 1'bz;
      end
      else if (io===1'bz)
      begin
        disable BlockPU;
        io_e = 1'bz;
        #0 ->Event_PU;
      end
    end
    else
    begin
      if (e_tmp==1'b0)
      begin
        case ({pu_tmp,pd_tmp,pscn_tmp})
          3'b101 :
          begin
            if (io===1'b1)
            begin
              disable BlockPU;
              io_e = 1'b1;
            end
            else if (io===1'b0)
            begin
              disable BlockPU;
              io_e = 1'bz;
            end
            else if (io===1'bz)
            begin
              disable BlockPU;
              io_e = 1'bz;
              #0 ->Event_PU;
            end
          end
          3'b011 :
          begin
            if (io===1'b0)
            begin
              disable BlockPD;
              io_e = 1'b0;
            end
            else if (io===1'b1)
            begin
              disable BlockPD;
              io_e = 1'bz;
            end
            else if (io===1'bz)
            begin
              disable BlockPD;
              io_e = 1'bz;
              #0 ->Event_PD;
            end
          end
          3'b001,
          3'b111 :
          begin
            // do nothing;
          end
          default : 
          begin
  	  io_e = 1'bx; 	 
          end
        endcase
      end
    end
  end

  always @(Event_DisableAll)
  begin:BlockDisableAll
    disable BlockPU;
    disable BlockPD;
  end

  always @(Event_PU)
  begin:BlockPU
    io_e = #THZ 1'b1;
  end

  always @(Event_PD)
  begin:BlockPD
    io_e = #THZ 1'b0;
  end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_ene_IO
// Cell Type : Primitive
// Version   : 1.2
// Revised on: 3/19 '03
///////////////////////////////////////////////
module  pullup_down_ene_IO (io, i, e, ne, pu, pd);

   input i, e, ne, pu, pd;
   inout io;

`protect

`ifdef ftc_gatelevel

`else
  `ifdef ftc_verify
    parameter THZ   = 4;
  `else
    parameter THZ   = 399999.9;
  `endif
 
  supply1 vcc;
  reg  io_e;
  wire io_i;
  wire e_tmp,ne_tmp,pu_tmp,pd_tmp;
  wire io_i_tmp;
 
  event Event_PU,
        Event_PD,
        Event_DisableAll;
 
  buf  g1 (pu_tmp, pu);
  buf  g2 (pd_tmp, pd);
  buf  g3 (e_tmp, e);
  buf  g4 (ne_tmp, ne);
 
  bufif1 g5 (io_i, i, e_tmp);
  rnmos  g6 (io_i_tmp, io_e, ne_tmp);  //-- pull level
  rnmos  g7 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
  nmos #0.1 g8 (io,   io_i, vcc);
 
  always @(e_tmp or pu_tmp or pd_tmp)
  begin
    ->Event_DisableAll;
    if (e_tmp == 1'b0)
    begin
      case ({pu_tmp,pd_tmp})
        2'b10 :
        begin
          if (io == 1'b1)
            io_e <= 1'b1;
          else
          begin
            if (io_e !== 1'bz)
              io_e <= 1'bz;
            else
            begin
	      #0 ->Event_PU;
            end 
          end
        end
        2'b01 :
        begin
          if (io == 1'b0)
            io_e <= 1'b0;
          else
          begin
            if (io_e !== 1'bz)
              io_e <= 1'bz;
            else
            begin
              #0 ->Event_PD;
            end
          end
        end
        2'b00,
        2'b11 :
        begin
          io_e <= 1'bz; 
        end
        default : 
	begin
          io_e <= 1'bx; 	 
	end
      endcase 
    end
  end

  always @(io)
  begin 
    if (e_tmp==1'b0)
    begin
      case ({pu_tmp,pd_tmp})
        2'b10 :
        begin
          if (io===1'b1)
          begin
            disable BlockPU;
            io_e = 1'b1;
          end
          else if (io===1'b0)
          begin
            disable BlockPU;
            io_e = 1'bz;
          end
          else if (io===1'bz)
          begin
            disable BlockPU;
            io_e = 1'bz;
            #0 ->Event_PU;
          end
        end
        2'b01 :
        begin
          if (io===1'b0)
          begin
            disable BlockPD;
            io_e = 1'b0;
          end
          else if (io===1'b1)
          begin
            disable BlockPD;
            io_e = 1'bz;
          end
          else if (io===1'bz)
          begin
            disable BlockPD;
            io_e = 1'bz;
            #0 ->Event_PD;
          end
        end
        2'b00,
        2'b11 :
        begin
          // do nothing;
        end
        default : 
        begin
	  io_e = 1'bx; 	 
        end
      endcase
    end
  end

  always @(Event_DisableAll)
  begin:BlockDisableAll
    disable BlockPU;
    disable BlockPD;
  end

  always @(Event_PU)
  begin:BlockPU
    io_e = #THZ 1'b1;
  end

  always @(Event_PD)
  begin:BlockPD
    io_e = #THZ 1'b0;
  end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_keep_IO
// Cell Type : Primitive
// Version   : 1.5
// Revised on: 5/12 '03
///////////////////////////////////////////////

module  pullup_down_keep_IO (io, i, e, pu, pd);

   input i, e, pu, pd;
   inout io;
   wire io1_tmp;

`protect

`ifdef ftc_gatelevel
   supply1 vcc;

   bufif1 g1(io1, i, e);
   not    g2(pub, pu);
   not    g3(pdb, pd);
   and    g4(pupd, pu, pd);
   and    g5(pu_pd_, pub, pdb);
   or     g6(pcon, pupd, pu_pd_);
   or     g7(pull_down1, pdb, pu);
   rpmos  g8(io1_tmp, pull_down1, pcon);  //-- pull level
   rnmos  g9(io1, io1_tmp, vcc);  //-- added for down scale to weak level   

   //-- bus holder for keep function --//
   buf    g10 (z,io1);
   buf    g11 (H,z);
   rnmos  g12 (io1, H, pupd);

   nmos   g13(io,io1,vcc);
`else

`ifdef ftc_verify
   parameter THZ   = 4;
`else
   parameter THZ   = 399999.9;
`endif

   supply1 vcc;
   reg  io_e;
   wire io_i, ne;
   wire e_tmp,pu_tmp,pd_tmp;
   wire io_i_tmp;

   event Event_PU,
         Event_PD,
         Event_KEEP,
         Event_DisableAll;

   buf  g1 (pu_tmp, pu);
   buf  g2 (pd_tmp, pd);
   buf  g3 (e_tmp, e);

   bufif1  g4 (io_i, i, e_tmp);
   not     g5 (ne, e_tmp);
   rnmos   g6 (io_i_tmp, io_e, ne);  //-- pull level
   rnmos   g7 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
   nmos #0.1 g8 (io,   io_i, vcc);

   always @(e_tmp or pu_tmp or pd_tmp)
   begin
     ->Event_DisableAll;
     if (e_tmp == 1'b0)
     begin
       case ({pu_tmp,pd_tmp})
         2'b10 :
         begin
           if (io == 1'b1)
             io_e <= 1'b1;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PU;
             end 
           end
         end
         2'b01 :
         begin
           if (io == 1'b0)
             io_e <= 1'b0;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PD;
             end
           end
         end
         2'b00 :
         begin
           io_e <= 1'bz;
         end
         2'b11 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e <= 1'bx; 	 
	 end
       endcase 
     end
   end

   always @(io)
   begin 
     if (e_tmp==1'b0)
     begin
       case ({pu_tmp,pd_tmp})
         2'b10 :
         begin
           if (io===1'b1)
           begin
             disable BlockPU;
             io_e = 1'b1;
           end
           else if (io===1'b0)
           begin
             disable BlockPU;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPU;
             io_e = 1'bz;
             #0 ->Event_PU;
           end
         end
         2'b01 :
         begin
           if (io===1'b0)
           begin
             disable BlockPD;
             io_e = 1'b0;
           end
           else if (io===1'b1)
           begin
             disable BlockPD;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPD;
             io_e = 1'bz;
             #0 ->Event_PD;
           end
         end
         2'b00 :
         begin
           io_e <= 1'bz;
         end
         2'b11 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e = 1'bx; 	 
	 end
       endcase
     end
   end

   always @(Event_DisableAll)
   begin:BlockDisableAll
     disable BlockPU;
     disable BlockPD;
     disable BlockKEEP;
   end

   always @(Event_PU)
   begin:BlockPU
     io_e = #THZ 1'b1;
   end

   always @(Event_PD)
   begin:BlockPD
     io_e = #THZ 1'b0;
   end

   always @(Event_KEEP)
   begin:BlockKEEP
     io_e = io;
   end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_keep_IO
// Cell Type : Primitive
// Version   : 1.5
// Revised on: 5/12 '03
///////////////////////////////////////////////

module  pullup_down_keep_IO_03us (io, i, e, pu, pd);

   input i, e, pu, pd;
   inout io;
   wire io1_tmp;

`protect

`ifdef ftc_gatelevel
   supply1 vcc;

   bufif1 g1(io1, i, e);
   not    g2(pub, pu);
   not    g3(pdb, pd);
   and    g4(pupd, pu, pd);
   and    g5(pu_pd_, pub, pdb);
   or     g6(pcon, pupd, pu_pd_);
   or     g7(pull_down1, pdb, pu);
   rpmos  g8(io1_tmp, pull_down1, pcon);  //-- pull level
   rnmos  g9(io1, io1_tmp, vcc);  //-- added for down scale to weak level   

   //-- bus holder for keep function --//
   buf    g10 (z,io1);
   buf    g11 (H,z);
   rnmos  g12 (io1, H, pupd);

   nmos   g13(io,io1,vcc);
`else

`ifdef ftc_verify
   parameter THZ   = 4;
   parameter THZ_PD   = 4;
`else
   parameter THZ   = 399999.9;
   parameter THZ_PD   = 30000.0;
`endif

   supply1 vcc;
   reg  io_e;
   wire io_i, ne;
   wire e_tmp,pu_tmp,pd_tmp;
   wire io_i_tmp;

   event Event_PU,
         Event_PD,
         Event_KEEP,
         Event_DisableAll;

   buf  g1 (pu_tmp, pu);
   buf  g2 (pd_tmp, pd);
   buf  g3 (e_tmp, e);

   bufif1  g4 (io_i, i, e_tmp);
   not     g5 (ne, e_tmp);
   rnmos   g6 (io_i_tmp, io_e, ne);  //-- pull level
   rnmos   g7 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
   nmos #0.1 g8 (io,   io_i, vcc);

   always @(e_tmp or pu_tmp or pd_tmp)
   begin
     ->Event_DisableAll;
     if (e_tmp == 1'b0)
     begin
       case ({pu_tmp,pd_tmp})
         2'b10 :
         begin
           if (io == 1'b1)
             io_e <= 1'b1;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PU;
             end 
           end
         end
         2'b01 :
         begin
           if (io == 1'b0)
             io_e <= 1'b0;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PD;
             end
           end
         end
         2'b00 :
         begin
           io_e <= 1'bz;
         end
         2'b11 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e <= 1'bx; 	 
	 end
       endcase 
     end
   end

   always @(io)
   begin 
     if (e_tmp==1'b0)
     begin
       case ({pu_tmp,pd_tmp})
         2'b10 :
         begin
           if (io===1'b1)
           begin
             disable BlockPU;
             io_e = 1'b1;
           end
           else if (io===1'b0)
           begin
             disable BlockPU;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPU;
             io_e = 1'bz;
             #0 ->Event_PU;
           end
         end
         2'b01 :
         begin
           if (io===1'b0)
           begin
             disable BlockPD;
             io_e = 1'b0;
           end
           else if (io===1'b1)
           begin
             disable BlockPD;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPD;
             io_e = 1'bz;
             #0 ->Event_PD;
           end
         end
         2'b00 :
         begin
           io_e <= 1'bz;
         end
         2'b11 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e = 1'bx; 	 
	 end
       endcase
     end
   end

   always @(Event_DisableAll)
   begin:BlockDisableAll
     disable BlockPU;
     disable BlockPD;
     disable BlockKEEP;
   end

   always @(Event_PU)
   begin:BlockPU
     io_e = #THZ 1'b1;
   end

   always @(Event_PD)
   begin:BlockPD
     io_e = #THZ_PD 1'b0;
   end

   always @(Event_KEEP)
   begin:BlockKEEP
     io_e = io;
   end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_keep_IO_IE
// Cell Type : Primitive
// Version   : 1.2
// Revised on: 5/12 '03
///////////////////////////////////////////////

module  pullup_down_keep_IO_IE (io, i, e, ie, pu, pd);

   input i, e, ie, pu, pd;
   inout io;

`protect

`ifdef ftc_gatelevel

`else

  `ifdef ftc_verify
     parameter THZ   = 4;
  `else
     parameter THZ   = 399999.9;
  `endif

   supply1 vcc;
   reg  io_e;
   wire io_i, ne;
   wire e_tmp,pu_tmp,pd_tmp;
   wire io_i_tmp;

   event Event_PU,
         Event_PD,
         Event_KEEP,
         Event_DisableAll;

   buf  b1 (pu_tmp, pu);
   buf  b2 (pd_tmp, pd);
   buf  b3 (e_tmp, e);
   buf  b4 (ie_tmp, ie);

   bufif1  g4 (io_i, i, e_tmp);
   not     g5 (ne, e_tmp);
   rnmos   g6 (io_i_tmp, io_e, ne);  //-- pull level
   rnmos   g7 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
   nmos #0.1 g8 (io,   io_i, vcc);

   always @(e_tmp or ie_tmp or pu_tmp or pd_tmp)
   begin
     ->Event_DisableAll;
     if (e_tmp == 1'b0)
     begin
       case ({pu_tmp,pd_tmp,ie_tmp})
         3'b100 ,
	 3'b101 ,
         3'b10z ,
	 3'b10x :
	 begin
           if (io == 1'b1)
             io_e <= 1'b1;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PU;
             end 
           end
         end
         3'b010 ,
	 3'b011 ,
         3'b01z ,
	 3'b01x ,
	 3'b110 :
         begin
           if (io == 1'b0)
             io_e <= 1'b0;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PD;
             end
           end
         end
         3'b000 ,
	 3'b001 ,
         3'b00z ,
	 3'b00x :
         begin
           io_e <= 1'bz;
         end
         3'b111 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e <= 1'bx; 	 
	 end
       endcase 
     end
   end

   always @(io)
   begin 
     if (e_tmp==1'b0)
     begin
       case ({pu_tmp,pd_tmp,ie_tmp})
         3'b100 ,
	 3'b101 ,
         3'b10z ,
	 3'b10x :
         begin
           if (io===1'b1)
           begin
             disable BlockPU;
             io_e = 1'b1;
           end
           else if (io===1'b0)
           begin
             disable BlockPU;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPU;
             io_e = 1'bz;
             #0 ->Event_PU;
           end
         end
         3'b010 ,
	 3'b011 ,
         3'b01z ,
	 3'b01x ,
	 3'b110 :
         begin
           if (io===1'b0)
           begin
             disable BlockPD;
             io_e = 1'b0;
           end
           else if (io===1'b1)
           begin
             disable BlockPD;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPD;
             io_e = 1'bz;
             #0 ->Event_PD;
           end
         end
         3'b000 ,
	 3'b001 ,
         3'b00z ,
	 3'b00x :
         begin
           io_e <= 1'bz;
         end
         3'b111 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e = 1'bx; 	 
	 end
       endcase
     end
   end

   always @(Event_DisableAll)
   begin:BlockDisableAll
     disable BlockPU;
     disable BlockPD;
     disable BlockKEEP;
   end

   always @(Event_PU)
   begin:BlockPU
     io_e = #THZ 1'b1;
   end

   always @(Event_PD)
   begin:BlockPD
     io_e = #THZ 1'b0;
   end

   always @(Event_KEEP)
   begin:BlockKEEP
     io_e = io;
   end

`endif   
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_down_keep_IO_IE
// Cell Type : Primitive
// Version   : 1.2
// Revised on: 5/12 '03
///////////////////////////////////////////////

module  pullup_down_keep_IO_IG (io, i, e, ig, pu, pd);

   input i, e, ig, pu, pd;
   inout io;

`protect

`ifdef ftc_gatelevel

`else

  `ifdef ftc_verify
     parameter THZ   = 4;
  `else
     parameter THZ   = 399999.9;
  `endif

   supply1 vcc;
   reg  io_e;
   wire io_i, ne;
   wire e_tmp,pu_tmp,pd_tmp;
   wire io_i_tmp;

   event Event_PU,
         Event_PD,
         Event_KEEP,
         Event_DisableAll;

   buf  b1 (pu_tmp, pu);
   buf  b2 (pd_tmp, pd);
   buf  b3 (e_tmp, e);
   buf  b4 (ig_tmp, ig);

   bufif1  g4 (io_i, i, e_tmp);
   not     g5 (ne, e_tmp);
   rnmos   g6 (io_i_tmp, io_e, ne);  //-- pull level
   rnmos   g7 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
   nmos #0.1 g8 (io,   io_i, vcc);

   always @(e_tmp or ig_tmp or pu_tmp or pd_tmp)
   begin
     ->Event_DisableAll;
     if (e_tmp == 1'b0)
     begin
       case ({pu_tmp,pd_tmp,ig_tmp})
         3'b100 ,
	 3'b101 ,
         3'b10z ,
	 3'b10x :
	 begin
           if (io == 1'b1)
             io_e <= 1'b1;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PU;
             end 
           end
         end
         3'b010 ,
	 3'b011 ,
         3'b01z ,
	 3'b01x ,
	 3'b111 :
         begin
           if (io == 1'b0)
             io_e <= 1'b0;
           else
           begin
             if (io_e !== 1'bz)
               io_e <= 1'bz;
             else
             begin
               #0 ->Event_PD;
             end
           end
         end
         3'b000 ,
	 3'b001 ,
         3'b00z ,
	 3'b00x :
         begin
           io_e <= 1'bz;
         end
         3'b110 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e <= 1'bx; 	 
	 end
       endcase 
     end
   end

   always @(io)
   begin 
     if (e_tmp==1'b0)
     begin
       case ({pu_tmp,pd_tmp,ig_tmp})
         3'b100 ,
	 3'b101 ,
         3'b10z ,
	 3'b10x :
         begin
           if (io===1'b1)
           begin
             disable BlockPU;
             io_e = 1'b1;
           end
           else if (io===1'b0)
           begin
             disable BlockPU;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPU;
             io_e = 1'bz;
             #0 ->Event_PU;
           end
         end
         3'b010 ,
	 3'b011 ,
         3'b01z ,
	 3'b01x ,
	 3'b111 :
         begin
           if (io===1'b0)
           begin
             disable BlockPD;
             io_e = 1'b0;
           end
           else if (io===1'b1)
           begin
             disable BlockPD;
             io_e = 1'bz;
           end
           else if (io===1'bz)
           begin
             disable BlockPD;
             io_e = 1'bz;
             #0 ->Event_PD;
           end
         end
         3'b000 ,
	 3'b001 ,
         3'b00z ,
	 3'b00x :
         begin
           io_e <= 1'bz;
         end
         3'b110 :
         begin
           #0 ->Event_KEEP;
         end
         default : 
	 begin
	   io_e = 1'bx; 	 
	 end
       endcase
     end
   end

   always @(Event_DisableAll)
   begin:BlockDisableAll
     disable BlockPU;
     disable BlockPD;
     disable BlockKEEP;
   end

   always @(Event_PU)
   begin:BlockPU
     io_e = #THZ 1'b1;
   end

   always @(Event_PD)
   begin:BlockPD
     io_e = #THZ 1'b0;
   end

   always @(Event_KEEP)
   begin:BlockKEEP
     io_e = io;
   end

`endif   
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : pullup_inv_IO
// Cell Type : Primitive
// Version   : 1.3
// Revised on: 8/20 '02
///////////////////////////////////////////////
module  pullup_inv_IO (io, i, e);

  input i, e;
  inout io;

`protect

`ifdef ftc_gatelevel
  tri1 io;

  notif1 (io, i, e);
`else

  `ifdef ftc_verify
     parameter THZ   = 4;
  `else
     parameter THZ   = 400000;
  `endif

   supply1 vcc;
   reg  io_e, pre;
   wire e_tmp, io_i, ne;
   wire io_i_tmp;

   event EventTHZ;

// Function

   buf      g1 (e_tmp, e);
   notif1   g2 (io_i, i, e_tmp);
   not      g3 (ne,   e_tmp);
   rnmos    g4 (io_i_tmp, io_e, ne);  //-- pull level
   rnmos    g5 (io_i, io_i_tmp, vcc);  //-- added for down scale to weak level   
   nmos     g6 (io,   io_i, vcc);

   always @(e_tmp)
   begin
     if (e_tmp == 1'b1)
     begin
       disable BlockTHZ;
     end
     else if (e_tmp == 1'b0)
     begin
       if (io == 1'b1)
         io_e <= 1'b1;
       else
       begin
         io_e <= 1'bz;
       end
     end
   end

   always @(io)
   begin
     if (e_tmp==1'b0)
     begin
       if (io===1'b1)
       begin
         disable BlockTHZ;
         io_e = 1'b1;
       end
       else if (io===1'b0)
       begin
         disable BlockTHZ;
         io_e = 1'bz;
       end
       else if (io===1'bz)
       begin
         disable BlockTHZ;
         io_e = 1'bz;
         #0 ->EventTHZ;
       end
     end
   end

   always @(EventTHZ)
   begin:BlockTHZ
     io_e = #THZ 1'b1;
   end

`endif
`endprotect
endmodule
///////////////////////////////////////////////
// Cell Name : tffrb_udp
// Cell Type : Primitive
// Version   : 1.3
// Date      : 11/02 2001
// Reason    :
//      1.3  : Modify protection method 
//      1.2  : Deal with unknown ck.
//      1.1  : Initial
///////////////////////////////////////////////

primitive   tffrb_udp (q, ck, rb, flag);
//
// TOGGLE FLIP FLOP WITH CLEAR/STANDARD DRIVE
   output q;
   reg q;
   input ck, rb, flag;// Clock.


`protect
   table
//    CK    RB  FLAG :   Qt : Qt+1
       r     1     ? :     0 :     1;// Toggle condition.
       r     1     ? :     1 :     0;
       r     x     ? :     1 :     0;
    (?0)     1     ? :     ? :     -;

       // deal with clk "x"
       b  (?1)     ? :     ? :     -;

       ?     0     ? :     ? :     0;
       ?     ?     * :     ? :     x;
   endtable
`endprotect
endprimitive

///////////////////////////////////////////////
// Cell Name : tffrsb_udp
// Cell Type : Primitive
// Version   : 1.3
// Date      : 11/02 2001
// Reason    :
//      1.3  : Modify protection method
//      1.2  : Deal with unknown ck.
//      1.1  : Initial
///////////////////////////////////////////////

primitive   tffrsb_udp(q, ck, rb, sb, flag);

// TOGGLE FLIP FLOP WITH SB & RB
   output q;
   reg q;
   input ck, sb, rb, flag;

`protect
   table
//    CK    RB    SB  FLAG :   Qt : Qt+1
       r     1     1     ? :     0 :     1;
       r     1     1     ? :     1 :     0;
       r     1     x     ? :     0 :     1;
       r     x     1     ? :     1 :     0;
    (?0)     1     1     ? :     ? :     -;

       ?     0     0     ? :     ? :     0;
       ?     0     1     ? :     ? :     0;
       ?     1     0     ? :     ? :     1;
       ?     0     x     ? :     ? :     0;

     // deal with clk "x"
       b  (?1)     1     ? :     ? :     -;
       b     1  (?1)     ? :     ? :     -;

       ?     ?     ?     * :     ? :     x;
   endtable
`endprotect
endprimitive
///////////////////////////////////////////////
// Cell Name : tffsb_udp
// Cell Type : Primitive
// Version   : 1.3
// Date      : 11/02 2001
// Reason    :
//      1.3  : Modify protection method
//      1.2  : Deal with unknown ck.
//      1.1  : Initial
///////////////////////////////////////////////

primitive   tffsb_udp(q, ck, sb, flag);
//
// TOGGLE FLIP FLOP WITH SB
   output q;
   reg q;
   input ck, sb, flag;// Clock.

`protect
   table
//    CK    SB  FLAG :   Qt : Qt+1
       r     1     ? :     0 :     1;// Toggle condition.
       r     1     ? :     1 :     0;
       r     x     ? :     0 :     1;
    (?0)     1     ? :     ? :     -;

     // deal with clk "x"
       b  (?1)     ? :     ? :     -;

       ?     0     ? :     ? :     1;
       ?     ?     * :     ? :     x;
   endtable
`endprotect
endprimitive
